<MudButton ButtonType="@ButtonType" Disabled="@(Disabled || _processing)" OnClick="ProcessSomething" Variant="@Variant" Color="@((_success ? SuccessColor : (_error ? ErrorColor : Color)).GetValueOrDefault())" Size="@Size">
    @if (_processing)
    {
        <MudProgressCircular Class="ms-n1" Size="Size.Small" Indeterminate="true"/>
        @if(LoadingText is not null) 
        {
            <MudText Class="ms-2">@LoadingText</MudText>
        }
    }
    else if(_error && !(ErrorText is null && ErrorIcon is null))
    {
        if(ErrorIcon is not null) 
        {
            <MudIcon Class="ms-n1" Size="Size.Small" Icon="@ErrorIcon" />
        }
        if(ErrorText is not null) 
        {
            <MudText Class="@(ErrorIcon is not null ? "ms-2" : string.Empty)">@ErrorText</MudText>
        }
    }
    else if(_success  && !(SuccessText is null && SuccessIcon is null))
    {
        if(SuccessIcon is not null) 
        {
            <MudIcon Class="ms-n1" Size="Size.Small" Icon="@SuccessIcon" />
        }
        if(ErrorText is not null) 
        {
            <MudText Class="@(SuccessIcon is not null ? "ms-2" : string.Empty)">@SuccessText</MudText>
        }
    }
    else
    {
        if(Icon is not null) 
        {
            <MudIcon Class="ms-n1" Size="Size.Small" Icon="@Icon" />
        }
        if(ChildContent is not null) 
        {
            <MudText Class="@(Icon is not null ? "ms-2" : string.Empty)">@ChildContent</MudText>
        }
    }
</MudButton>

@code {
    private bool _processing = false;
    private bool _success =  false;
    private bool _error =  false;
    private CancellationTokenSource? cts;
    private Task? resetTask;

    [Parameter]
    public ButtonType ButtonType { get; set; } = MudBlazor.ButtonType.Button;

    [Parameter]
    public bool Disabled { get; set; }

    [Parameter]
    public string? Icon { get; set; }

    [Parameter]
    public EventCallback OnClick { get; set; } = default!;

    [Parameter]
    public RenderFragment ChildContent { get; set; } = default!;

    [Parameter]
    public string? LoadingText { get; set; }

    [Parameter]
    public string? ErrorIcon { get; set; } = Icons.Material.Filled.Error;

    [Parameter]
    public Color? ErrorColor { get; set; } = MudBlazor.Color.Error;

    [Parameter]
    public string? ErrorText { get; set; } = "Try again";

    public string? SuccessIcon { get; set; } = Icons.Material.Filled.Check;

    [Parameter]
    public Color? SuccessColor { get; set; } = MudBlazor.Color.Success;

    [Parameter]
    public string? SuccessText { get; set; } = "Success";

    [Parameter]
    public Variant Variant { get; set; } = MudBlazor.Variant.Text;

    [Parameter]
    public Color Color { get; set; } = MudBlazor.Color.Default;

    [Parameter]
    public Size Size { get; set; } = MudBlazor.Size.Medium;

    /// <summary>
    /// The time after which the button shows the processing state.
    /// </summary>
    [Parameter]
    public TimeSpan Timeout { get; set; } = TimeSpan.FromSeconds(0);

    /// <summary>
    /// The time after which the button will reset.
    /// </summary>
    [Parameter]
    public TimeSpan ResetTime { get; set; } = TimeSpan.FromSeconds(2);

    [Parameter]
    public bool ResetOnSuccess { get; set; } = true;

    [Parameter]
    public bool ResetOnFailure { get; set; } = true;

    public void Reset() 
    {
        _processing = false;
        _error = false;
        _success = false;
    }

    public Func<Task> Decorate(Func<Task> handler)
    {
        return async () => await InvokeHandler(handler);
    }

    public async Task InvokeHandler(Func<Task> handler)
    {
        _success =  false;
        _error = false;

        cts = new ();
        Task? t = null;

        try 
        {
            if(Timeout.TotalMilliseconds > 0) 
            {
                t = Task.Delay(Timeout).ContinueWith((task) => { 
                        _processing = true;
                        InvokeAsync(StateHasChanged); 
                    }, cts.Token);
            }
            else
            {
                _processing = true;
            }

            await handler();

            _success =  true;

            StateHasChanged();
        }
        catch(TaskCanceledException)
        {

        }
        catch
        {
            _error = true;
        }
        finally 
        {
            cts.Cancel();
            _processing = false;
            
            if(ResetTime.TotalMilliseconds > 0 && ((_success && ResetOnSuccess) || (_error && ResetOnFailure))) 
            {
                resetTask = Task.Delay(ResetTime).ContinueWith((task) => { 
                    Reset();
                    InvokeAsync(StateHasChanged); 
                });
            }
        }
    }

    async Task ProcessSomething()
    {
        await InvokeHandler(async () => {
            await OnClick.InvokeAsync();
        });
    }
}